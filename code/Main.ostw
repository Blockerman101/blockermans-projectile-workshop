import "../customGameSettings.json";
//import "../../../Other/extraFunctions.ostw";
import "BMPW/simpleProcessing.del";
import "BMPW/complexProcessing.del";
import "BMPW/projConstructor.del";
import "BMPW/projDestructor.del";
import "BMPW/structs.del";
import "_flight.del";
import "_dev.del";

disabled rule: '[DEV] Text'
{
    CreateHudText(HostPlayer(), "Load: " + ServerLoad(), null, null, Location.Right, -1, ServerLoad() >= 100 ? (ServerLoad() >= 200 ? Color.Red : Color.Yellow) : Color.Green, null, null, HudTextRev.VisibleToSortOrderStringAndColor, Spectators.DefaultVisibility);
    CreateHudText(HostPlayer(), UpdateEveryFrame("Size (Fake): " + projData.Length), null, null, Location.Right, -1, Color.White, null, null, HudTextRev.VisibleToSortOrderStringAndColor, Spectators.DefaultVisibility);
    CreateHudText(HostPlayer(), UpdateEveryFrame("Size (Real): " + projData.Map(v => v.HitPlayer).Length), null, null, Location.Right, -1, Color.White, null, null, HudTextRev.VisibleToSortOrderStringAndColor, Spectators.DefaultVisibility);
    CreateHudText(HostPlayer(), UpdateEveryFrame("E-Count: " + EntityCount()), null, null, Location.Right, -1, Color.White, null, null, HudTextRev.VisibleToSortOrderStringAndColor, Spectators.DefaultVisibility);
    CreateHudText(HostPlayer(), UpdateEveryFrame("Inactive: " + projData.Filter(v => v.ProjState == ProjState.Inactive).Length), null, null, Location.Right, -1, Color.White, null, null, HudTextRev.VisibleToSortOrderStringAndColor, Spectators.DefaultVisibility);
    speed(2);
}
disabled rule: '[DEV] log changes'
//if (projData.Length != length)g
{
    //length = projData.Length;
    //length \t load
    LogToInspector($"{TotalTimeElapsed()}\n{ServerLoad()}\n\n");
    Wait(0.1);
    LoopIfConditionIsTrue();
}

rule: '[DEV] remove dmg'
//if (AllPlayers().Length != EvaluateOnce(AllPlayers().Length))
if (HasSpawned(HostPlayer()))
{
    StartDamageModification(HostPlayer(), AllPlayers(OppositeTeamOf(HostPlayer().Team())), 0.5, DamageModificationRev.ReceiversAndDamagers);
    SetKnockbackReceived(HostPlayer(), 0);
}



disabled rule: 'Make my projectile'
Event.OngoingPlayer
if (EventPlayer().IsButtonHeld(Button.Interact))
if (!EventPlayer().IsButtonHeld(Button.Crouch))
//if (EventPlayer() == HostPlayer())
{
    ProjectileArgs shortProj: {ProjFX: ProjFX.GenjiShuriken, Lifetime: 5, Speed: ProjectileArgs.Default().Speed, ..ProjectileArgs.Default()};
    CreateCustomProjectile(shortProj);
    //Number myID = lastProjectileID;
    Wait(0.25, WaitBehavior.AbortWhenFalse);
    LoopIfConditionIsTrue();
}

private playervar Number[] bigProjIDs = [];
rule: 'Make big proj'
Event.OngoingPlayer
if (EventPlayer().IsButtonHeld(Button.PrimaryFire))
if (!EventPlayer().IsButtonHeld(Button.Crouch))
//if (EventPlayer() == HostPlayer())
{
    ProjectileArgs bigProj: {ProjFX: ProjFX.BaptisteBioticLauncher, Oversize: 0.2, Speed: 50, Lifetime: 5, ..ProjectileArgs.Default()};
    CreateCustomProjectile(bigProj);
    bigProjIDs.ModAppend(lastProjectileID);
    LogToInspector("I appended proj " + lastProjectileID);
    MinWait();
    //LoopIfConditionIsTrue();
}

rule: 'Explode big projs!'
Event.OngoingPlayer
if (bigProjIDs.Any(v => projData[v].ProjState == ProjState.Inactive))
{
    LogToInspector("Kaboom!");
    _waitlessIterator = 0;
    while (_waitlessIterator <= bigProjIDs.Length) {
        ProjData current: projData[bigProjIDs[_waitlessIterator]];
        if (current.ProjState == ProjState.Inactive)
        {
            //if the projectile hit a player, do stuff, then traverse to next in line (by removing it)
            if (current.HitPlayer)
            {
                //PlayEffect(AllPlayers(), PlayEffect.GoodExplosion, Color.Red, current.Position, 15);
                //PlayEffect(AllPlayers(), PlayEffect.BuffExplosionSound, TeamOf(EventPlayer()), current.Position, 150);
                SetStatus(current.HitPlayer, EventPlayer(), Status.KnockedDown, 0.2);
                LogToInspector($"registered that proj {bigProjIDs[_waitlessIterator]} hit! (trying to hit {current.HitPlayer})");
                //Damage(current.HitPlayer, EventPlayer(), 50);
            }
                bigProjIDs.ModRemoveByIndex(_waitlessIterator);
        }
        //otherwise, traverse to next in line
        else
        {
            _waitlessIterator++;
        }
    }
    MinWait();
    LoopIfConditionIsTrue();
}

rule: 'Track helix rockets'
Event.OngoingPlayer
if (EventPlayer().IsFiringSecondary())
if (!EventPlayer().IsButtonHeld(Button.Crouch))
if (EventPlayer() == HostPlayer())
{
    ProjectileArgs myArgs = {ProjFX: ProjFX.PharahRocket, StartPosition: EventPlayer().EyePosition(), Speed: 50, Gravity: Vector.Zero, Lifetime: 2, ..ProjectileArgs.Default()};
    CreateCustomProjectile(myArgs);
}

    Vector RandomSpread(Player player, Number deviation): (player.FacingDirection() * CosineFromDegrees(RandomReal(0, deviation)) + SineFromDegrees(RandomReal(0, deviation)) * (Right().AsWorldVector(player, Transformation.Rotation) * CosineFromDegrees(RandomReal(0, 360)) + CrossProduct(player.FacingDirection(), Left().AsWorldVector(player, Transformation.Rotation)) * SineFromDegrees(RandomReal(0, 360)))).Normalize();


//For an array of structs, you can filter/use a single value by doing structArray.Map(v => v.value)
//Arrays have to index linearly/incrementally. myArray = [5, 2, 4]; myArray[7] = 10; output: [5, 2, 4, 0, 0, 0, 0, 10]
//
//String => void message = text => BigMessage(AllPlayers(), text);
//String => void message                 | [argument data type] => [function return type] [function name]
// "="                                   | set the function 'message' to this
//text => BigMessage(AllPlayers(), text) | [argument name] => [expression]