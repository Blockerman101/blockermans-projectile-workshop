import "../customGameSettings.json";
//import "../../../Other/extraFunctions.ostw";
import "BMPW/simpleProcessing.del";
import "BMPW/complexProcessing.del";
import "BMPW/projConstructor.del";
import "BMPW/projDestructor.del";
import "BMPW/structs.del";
//import "_flight.del";
//import "_dev.del";
import "uiTwo.del";

rule: '[DEV] remove dmg'
//if (AllPlayers().Length != EvaluateOnce(AllPlayers().Length))
if (HasSpawned(HostPlayer()))
{
    StartDamageModification(HostPlayer(), AllPlayers(OppositeTeamOf(HostPlayer().Team())), 0.5, DamageModificationRev.ReceiversAndDamagers);
    SetKnockbackReceived(HostPlayer(), 0);
}

rule: 'Make my projectile'
Event.OngoingPlayer
if (EventPlayer().IsButtonHeld(Button.Interact))
if (!EventPlayer().IsButtonHeld(Button.Crouch))
//if (EventPlayer() == HostPlayer())
{
    updateInconstants();
    //ProjectileArgs shortProj: {ProjFX: ProjFX.GenjiShuriken, Lifetime: 5, Speed: ProjectileArgs.Default().Speed, ..ProjectileArgs.Default()};
    CreateCustomProjectile(EventPlayer()._projArgs);
    //Number myID = lastProjectileID;
    Wait(0.25, WaitBehavior.AbortWhenFalse);
    LoopIfConditionIsTrue();
}

    Vector RandomSpread(Player player, Number deviation): (player.FacingDirection() * CosineFromDegrees(RandomReal(0, deviation)) + SineFromDegrees(RandomReal(0, deviation)) * (Right().AsWorldVector(player, Transformation.Rotation) * CosineFromDegrees(RandomReal(0, 360)) + CrossProduct(player.FacingDirection(), Left().AsWorldVector(player, Transformation.Rotation)) * SineFromDegrees(RandomReal(0, 360)))).Normalize();


//For an array of structs, you can filter/use a single value by doing structArray.Map(v => v.value)
//Arrays have to index linearly/incrementally. myArray = [5, 2, 4]; myArray[7] = 10; output: [5, 2, 4, 0, 0, 0, 0, 10]
//
//String => void message = text => BigMessage(AllPlayers(), text);
//String => void message                 | [argument data type] => [function return type] [function name]
// "="                                   | set the function 'message' to this
//text => BigMessage(AllPlayers(), text) | [argument name] => [expression]