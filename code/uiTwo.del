import "BMPW/structs.del";
//import "../../../Other/extraFunctions.ostw";
import "tx.del";
//import "mynewfile.del";

enum UIType
{
    NULL,
    Number,
    Vector,
    Boolean,
    //Takes 2 inputs to render true/false, rather than one
    //0 -> Vector.Zero -> 1
    //1 -> " " -> 0
    TwoStepBoolean,
    Special
    //ProjFX,
    //ExportArgs
}

single struct ProjArgData
{
    //When arg is said, its implied that its a projectile argument, such as speed, direction, lifetime
    //Name is the name of the arg, ex. Speed
    //Value refers to the value of an arg, ex. Speed: 20, 20 is the value
    //Text refers to the displayed text of a value of an arg, on the ui. It can be overridden without changing what value is
    

    //The corresponding index in ProjectileArgs
    public Number Pointer;
    //Whether this arg is used internally, or can be set by the player
    public Boolean Internal;
    public UIType UIType;
    //Whether the default value for this arg is constant. ex. startPos = Eye Position is not constant, speed = 20 is
    public String TextForInconstantValue;
    public String Name; //Never changes
    public Boolean IsArg;
    public () => String OverrideText;
    //OverrideText is used to update OverriddenText
    public String _OverriddenText;
    public Any ValueForNonArg;
    //public Any Arg(in Player player=EventPlayer()): args(player)[this.Pointer];

    //Number is incOrDec, a scalar of 1 or -1 depending on if the operation is for incrementing or decrementing
    public (Number) => void ActionForSpecialType;
    //The minimum and maximum values for this arg
    public Number[] MinAndMax;
    public Any Value(in Player player=HostPlayer()): (OverrideText ? (_OverriddenText) : (IsArg ? player._projArgs[Pointer] : ValueForNonArg));
    public ref void UpdateOverriddenText() {_OverriddenText = OverrideText.Invoke();}

    public static ProjArgData Construct(): {
        Pointer: null,
        Internal: false,
        UIType: UIType.NULL,
        TextForInconstantValue: "",
        Name: "",
        IsArg: true,
        OverrideText: null,
        _OverriddenText: null,
        ValueForNonArg: null,
        ActionForSpecialType: null,
        MinAndMax: [-1000000, 1000000]
    };
}


globalvar ProjArgData[] UI = [
    //_ProjID
    {
        Pointer: 0,
        Internal: true,
        //Name: "_ProjID",
        ..ProjArgData.Construct()
    },

    //ProjFX
    {
        Pointer: 1,
        Internal: false,
        UIType: UIType.Special,
        ActionForSpecialType: incOrDec => {
            EventPlayer()._projArgs[ArgIndexForUI.First] = ((EventPlayer()._projArgs[ArgIndexForUI.First] + incOrDec) >= 0 ? (EventPlayer()._projArgs[ArgIndexForUI.First] + incOrDec)%countOfProjFX : countOfProjFX - 1);
            //projArgDataForUI[ArgIndexForUI.First].UpdateOverriddenText(<'<0> (<1>)', PFXToText(args.ProjFX), args.ProjFX>);
        },
        Name: "Proj FX",
        //THE TROUBLEMAKER
        //OverrideText: <'<0> (<1>)', PFXToText(args.ProjFX), args.ProjFX>,
        OverrideText: () => <'<0> (<1>)', PFXToText(args.ProjFX), args.ProjFX>,
        ..ProjArgData.Construct()
    },

    //StartPosition
    {
        Pointer: 2,
        Internal: false,
        UIType: UIType.Vector,
        Name: "Start Position",
        TextForInconstantValue: "Eye Position(EP)",
        ..ProjArgData.Construct()
    },
    //Direction
    {
        Pointer: 3,
        Internal: false,
        UIType: UIType.Vector,
        Name: "Direction",
        TextForInconstantValue: "Facing Dir(EP)",
        ..ProjArgData.Construct()
    },

    //Targets
    {
        Pointer: 4,
        Internal: false,
        Name: "Targets",
        TextForInconstantValue: "All Players(Opp Team(Team(EP)))",
        ..ProjArgData.Construct()
    },

    //Oversize
    {
        Pointer: 5,
        Internal: false,
        UIType: UIType.Number,
        Name: "Oversize",
        MinAndMax: [0, 1],
        ..ProjArgData.Construct()
    },
    //Speed
    {
        Pointer: 6,
        Internal: false,
        UIType: UIType.Number,
        Name: "Speed",
        ..ProjArgData.Construct()
    },

    //Lifetime
    {
        Pointer: 7,
        Internal: false,
        UIType: UIType.Number,
        Name: "Lifetime",
        MinAndMax: [0, 60],
        ..ProjArgData.Construct()
    },

    //Gravity
    {
        Pointer: 8,
        Internal: false,
        UIType: UIType.Vector,
        Name: "Gravity",
        ..ProjArgData.Construct()
    },

    //_TimeOfCall
    {
        Pointer: 9,
        Internal: true,
        //Name: "_TimeOfCall",
        ..ProjArgData.Construct()
    },

    //Export Actions
    {
        Pointer: 10,
        Internal: false,
        IsArg: false,
        Name: "Export",
        ValueForNonArg: false,
        UIType: UIType.TwoStepBoolean,
        //ActionForSpecialType: incOrDec => {UI[10].ValueForNonArg += 1;},
        //TextForValue: ,
        //OverrideText: () => <"<0>", UI[10].ValueForNonArg == 0 ? (UI[10].ValueForNonArg == 1 ? "Exported!" : "Click Again To Confirm") : "Click To Export">,
        //OverrideText: () => (UI[10].ValueForNonArg == true),
        ..ProjArgData.Construct()
    },

    //Use Raw Values
    {
        Pointer: 11,
        Internal: false,
        Name: "Use raw values",
        UIType: UIType.TwoStepBoolean,
        IsArg: false,
        ValueForNonArg: false,
        ..ProjArgData.Construct()
    },

    //Change button to fire proj
    {
        Pointer: 12,
        Name: "Firing button",
        IsArg: false,
        UIType: UIType.Special,
        ActionForSpecialType: incOrDec => {
            //((EventPlayer()._projArgs[ArgIndexForUI.First] + incOrDec) >= 0 ? (EventPlayer()._projArgs[ArgIndexForUI.First] + incOrDec)%countOfProjFX : countOfProjFX - 1);
            UI[12].ValueForNonArg = (buttonsForFiringButton.IndexOf(UI[12].ValueForNonArg) + incOrDec >= 0 ? buttonsForFiringButton[(buttonsForFiringButton.IndexOf(UI[12].ValueForNonArg) + incOrDec)%buttonsForFiringButton.Length] : buttonsForFiringButton.Last);
        },
        ValueForNonArg: Button.Interact,
        //OverrideText: () => <"<0>", ButtonToText(UI[12].ValueForNonArg)>,
        ..ProjArgData.Construct()
    }
];


Button[] buttonsForFiringButton: [Button.Ability1, Button.Ability2, Button.Crouch, Button.Interact, Button.Jump, Button.Melee, Button.PrimaryFire, Button.Reload, Button.SecondaryFire, Button.Ultimate];
public String ButtonToText(in Button button) {
    switch (button)
    {
        case Button.Ability1:       return "Ability 1";         break;
        case Button.Ability2:       return "Ability 2";         break;
        case Button.Crouch:         return "Crouch";            break;
        case Button.Interact:       return "Interact";          break;
        case Button.Jump:           return "Jump";              break;
        case Button.Melee:          return "Melee";             break;
        case Button.PrimaryFire:    return "Primary Fire";      break;
        case Button.Reload:         return "Reload";            break;
        case Button.SecondaryFire:  return "Secondary Fire";    break;
        case Button.Ultimate:       return "Ultimate";          break;
    }
}

//struct ProjArgDataForUI
//{
//    public ProjArgData[] data;
//    //public Any Arg: ;
//    //public Number Pointer: ;
//    public void 
//}



//"_ProjID",
//"Proj FX",
//"Start Position",
//"Direction",
//"Targets",
//"Oversize",
//"Speed",
//"Lifetime",
//"Gravity",
//"_TimeOfCall",

ProjectileArgs args: HostPlayer()._projArgs;
Player hp: HostPlayer();
playervar ProjectileArgs _projArgs = ProjectileArgs.Default();
ProjectileArgs defaultArgsWithVectors: {StartPosition: Vector(0,0,0), Direction: Vector(0,0,0), ..ProjectileArgs.Default(hp)};

void updateInconstants(in Player player=HostPlayer()) {
    if (!UI[11].ValueForNonArg) {
        for (_waitlessIterator = 0; _waitlessIterator < CountOf(player._projArgs); _waitlessIterator++) {
            if (UI[_waitlessIterator].TextForInconstantValue) {
            player._projArgs[_waitlessIterator] = ProjectileArgs.Default(player)[_waitlessIterator];
            }
        }   
    }
}

single struct ActionsForUIPress
{
    public Button button;
    public String toString: InputBindingString(this.button);
}
ActionsForUIPress[] bindings: [
    //Down
    {
        button: Button.Crouch
    },

    //Up
    {
        button: Button.Jump
    },

    //IncreaseChange
    {
        button: Button.Ability2
    },

    //DecreaseChange
    {
        button: Button.Ability1
    },

    //IncreaseByChange
    {
        button: Button.PrimaryFire
    },

    //DecreaseByChange
    {
        button: Button.SecondaryFire
    }

];
playervar Boolean editingArgs;
globalvar Number changeSize = 1;
globalvar Number[] ArgIndexForUI = [externalPointers.First];


rule: '[BMPW] Create text showing proj args'
if (UI.Length)
{
    Player lp: LocalPlayer();

    //Create FX for showing raw StartPos and Dir
    CreateEffect(UI[11].ValueForNonArg ? lp : null, Effect.Sphere, Color.Red, args.StartPosition, 0.5, EffectRev.VisibleToPositionAndRadius);
    CreateEffect(UI[11].ValueForNonArg ? lp : null, Effect.Sphere, Color.White, args.StartPosition + args.Direction.Normalize() * 0.5, 0.125, EffectRev.VisibleToPositionAndRadius);
    CreateBeamEffect(UI[11].ValueForNonArg ? lp : null, BeamType.GrappleBeam, args.StartPosition, args.StartPosition + args.Direction.Normalize() * 0.5, Color.White, EffectRev.VisibleToPositionAndRadius);

    Wait(1);
    CreateHudText(VisibleTo: LocalPlayer(),
        Header: (!lp.editingArgs ? $"Press {makeFG('fg55FF55FF', InputBindingString(UI[12].ValueForNonArg))} to fire projectile!" : makeFG('fg990000FF', 'Stop editing args to be able to fire projectile')) + $"\nPress {InputBindingString(Button.Crouch)} + {InputBindingString(Button.PrimaryFire)} to start/stop editing\nPress {InputBindingString(Button.Crouch)} + {InputBindingString(Button.SecondaryFire)} to change heroes",
        Location: Location.Left, SortOrder: -1, Reevaluation: HudTextRev.VisibleToAndString, Spectators: Spectators.DefaultVisibility);
    String colorForBindings: 'fg7777FFFF';
    CreateHudText(VisibleTo: LocalPlayer(),
        Header: !lp.editingArgs ? "" : $"Down: {makeFG(colorForBindings, bindings[0].toString)} | Up: {makeFG(colorForBindings, bindings[1].toString)}\nIncrease Change: {makeFG(colorForBindings, bindings[2].toString)} | Decrease Change: {makeFG(colorForBindings, bindings[3].toString)}\nIncrease By Change: {makeFG(colorForBindings, bindings[4].toString)} | Decrease By Change: {makeFG(colorForBindings, bindings[5].toString)}",
        Location: Location.Left, SortOrder: -1, Reevaluation: HudTextRev.VisibleToAndString, Spectators: Spectators.DefaultVisibility);
    for (_waitlessIterator = 0; _waitlessIterator < UI.Length; _waitlessIterator++)
    {
        Number i: _waitlessIterator;
        Number ie: EvaluateOnce(i);
        ProjArgData current: UI[ie];

        //Update initial
        LogToInspector("Updated");
        UI[i].UpdateOverriddenText();

        //Split into 3 different strings, 1 for each vector component
        String[] valueToSplitVectorString: [<"<0>", XOf(args[current.Pointer])>, <"<0>", YOf(args[current.Pointer])>, <"<0>", ZOf(args[current.Pointer])>];
        Any addPointer: (ArgIndexForUI.First != current.Pointer || !hp.editingArgs ? "" : makeFG("fgFF0000FF", $"←±{changeSize}"));
        
        if (!UI[i].Internal)
        {
            CreateHudText(
                VisibleTo: LocalPlayer(),
                //Header: $"Press {InputBindingString(Button.Crouch)} + {InputBindingString(Button.Interact)} to change args",
                Subheader: null,
                Text:
                    $"{current.Name}" + (current.UIType == UIType.TwoStepBoolean ? " (Click Twice): " : ": ") + 
                    ((current.TextForInconstantValue && !UI[11].ValueForNonArg) ? $"{current.TextForInconstantValue}" + addPointer : 
                        (
                            (current.UIType == UIType.Vector) ? 
                                "(" + valueToSplitVectorString.First + ((ArgIndexForUI.First == current.Pointer && ArgIndexForUI[1] == (0)) && lp.editingArgs ? makeFG("fgFF0000FF", $"←±{changeSize}") : "") + 
                                ", " + valueToSplitVectorString[1]   + ((ArgIndexForUI.First == current.Pointer && ArgIndexForUI[1] == (1)) && lp.editingArgs ? makeFG("fgFF0000FF", $"←±{changeSize}") : "") + 
                                ", " + valueToSplitVectorString[2]   + ((ArgIndexForUI.First == current.Pointer && ArgIndexForUI[1] == (2)) && lp.editingArgs ? makeFG("fgFF0000FF", $"←±{changeSize}") : "") +
                                ")"
                            : (current.UIType == UIType.TwoStepBoolean) ? 
                                ((current.Value() ? "True" : "False") + addPointer)
                            :
                                $"{current.Value()}" + addPointer
                        )
                    )
                
                ,

                Location: Location.Left,
                SortOrder: -1,
                //HeaderColor: ,
                //SubheaderColor: ,
                TextColor: current.IsArg ? Color.White : CustomColor(175, 175, 175, 255),
                Reevaluation: HudTextRev.VisibleToAndString,
                Spectators: Spectators.DefaultVisibility
            );
            LogToInspector($"Created {current.Name}");
        }
    }
}


Number[] externalPointers: UI.Filter(v => !v.Internal).Map(v => v.Pointer);
playervar Number indexInExternalPointers = 0;

rule: 'toggle editing args & process inputs'
Event.OngoingPlayer
if ((bindings.Any(v => IsButtonHeld(EventPlayer(), v.button)) && editingArgs) || (IsButtonHeld(EventPlayer(), Button.Crouch) && IsButtonHeld(EventPlayer(), Button.PrimaryFire)))
{   
    //SmallMessage(HostPlayer(), "rule fired");
    Button[] buttonsHeld = bindings.Map(v => v.button).Filter(v => IsButtonHeld(EventPlayer(), v));
    Number numberOfButtonsForTogglingEditingPressed: [Button.Crouch, Button.PrimaryFire].Filter(v => IsButtonHeld(EventPlayer(), v)).Length;

    
    
    //XOR
    if (numberOfButtonsForTogglingEditingPressed == 1) {
        //Gives player 1 second to do keystrokes for toggling editing args
        WaitUntil(numberOfButtonsForTogglingEditingPressed != 1, 1);
    }

    if (IsButtonHeld(EventPlayer(), Button.Crouch) && IsButtonHeld(EventPlayer(), Button.PrimaryFire)) {
        editingArgs = !editingArgs;
        //toggle bindings
            for (_waitlessIterator = 0; _waitlessIterator < bindings.Length; _waitlessIterator++) {
        if (editingArgs) {
            DisallowButton(EventPlayer(), bindings[_waitlessIterator].button);
        } else {
            AllowButton(EventPlayer(), bindings[_waitlessIterator].button);
        }
        }
    } else if (editingArgs) {
        //SmallMessage(HostPlayer(), "switched!");

        //The currently selected arg
        ProjArgData current: UI[ArgIndexForUI.First];

        switch (buttonsHeld.First)
        {
            //Down
            case bindings[0].button:   if (UI[ArgIndexForUI.First].UIType == UIType.Vector && ArgIndexForUI[1] < 2 && (!UI[ArgIndexForUI.First].TextForInconstantValue || UI[11].ValueForNonArg)) {
                    ArgIndexForUI[1] += 1;
                } else {
                    indexInExternalPointers = (indexInExternalPointers + 1)%(externalPointers.Length);
                    //Traverse to the next external pointer (circular)
                    ArgIndexForUI[0] = externalPointers[indexInExternalPointers];
                    //ArgIndexForUI[0] += 1;
                    ArgIndexForUI[1] = 0;
                } break;
            
            //Up
            case bindings[1].button:   if (UI[ArgIndexForUI.First].UIType == UIType.Vector && ArgIndexForUI[1] > 0 && (!UI[ArgIndexForUI.First].TextForInconstantValue || UI[11].ValueForNonArg)) {
                    ArgIndexForUI[1] -= 1;
                } else {
                    indexInExternalPointers = !indexInExternalPointers ? externalPointers.Length - 1 : (indexInExternalPointers - 1)%(externalPointers.Length);
                    //Traverse to the previous external pointer (circular)
                    ArgIndexForUI[0] = externalPointers[indexInExternalPointers];
                    //ArgIndexForUI[0] -= 1;
                    ArgIndexForUI[1] = 2;
                } break;
            
            //IncreaseChange
            case bindings[2].button:   changeSize *= 10; changeSize = Min(changeSize, 10000);   break;
            
            //DecreaseChange
            case bindings[3].button:   changeSize /= 10; changeSize = Max(changeSize, 0.001);   break;
            
            Number incOrDec: (buttonsHeld.First == bindings[4].button ? 1 : -1);
            //IncreaseByChange || DecreaseByChange
            case bindings[4].button:
            case bindings[5].button:
                //if (current.IsArg) {
                //TEMP || true FOR DEV
                //May not be needed in general
                    if (!current.TextForInconstantValue || true) {
                        switch(current.UIType) {
                            //If type -> if increase button is held, increase, else, decrease
                            case UIType.Number:
                                if (current.IsArg) {
                                    EventPlayer()._projArgs[ArgIndexForUI.First] += changeSize * incOrDec;
                                    EventPlayer()._projArgs[ArgIndexForUI.First] = Clamp(EventPlayer()._projArgs[ArgIndexForUI.First], current.MinAndMax.First, current.MinAndMax[1]);
                                } else {
                                    UI[ArgIndexForUI.First].ValueForNonArg += changeSize * incOrDec;
                                    UI[ArgIndexForUI.First].ValueForNonArg = Clamp(UI[ArgIndexForUI.First].ValueForNonArg, current.MinAndMax.First, current.MinAndMax[1]);
                                }
                                break;

                            //Switch through the diff components
                            case UIType.Vector: {
                                if (current.IsArg) {
                                    //the different indexes/components of a vector (0 = x, 1 = y, 2 = z)
                                    switch (ArgIndexForUI[1]) {
                                        case 0: EventPlayer()._projArgs[ArgIndexForUI.First] += Vector(changeSize, 0, 0) * incOrDec; break;
                                        case 1: EventPlayer()._projArgs[ArgIndexForUI.First] += Vector(0, changeSize, 0) * incOrDec; break;
                                        case 2: EventPlayer()._projArgs[ArgIndexForUI.First] += Vector(0, 0, changeSize) * incOrDec; break;
                                    }
                                } else {
                                    switch (ArgIndexForUI[1]) {
                                        case 0: UI[ArgIndexForUI.First].ValueForNonArg += Vector(changeSize, 0, 0) * incOrDec; break;
                                        case 1: UI[ArgIndexForUI.First].ValueForNonArg += Vector(0, changeSize, 0) * incOrDec; break;
                                        case 2: UI[ArgIndexForUI.First].ValueForNonArg += Vector(0, 0, changeSize) * incOrDec; break;
                                    }
                                }
                            } break;

                            //Flip booleans
                            case UIType.Boolean: if (current.IsArg) {
                                EventPlayer()._projArgs[ArgIndexForUI.First] = !EventPlayer()._projArgs[ArgIndexForUI.First];
                            } else {
                                UI[ArgIndexForUI.First].ValueForNonArg = !current.ValueForNonArg;
                            }break;
                            
                            case UIType.TwoStepBoolean:
                                if (current.Value() == 1 || current.Value() == 0) {
                                    twoStepBooleanTimer.ModAppend([current.Pointer, TotalTimeElapsed()]);
                                } else {
                                    PlayEffect(HostPlayer(), PlayEffect.BuffImpactSound, null, EyePosition(hp), 150);
                                }
                                if (current.IsArg) {
                                    EventPlayer()._projArgs[ArgIndexForUI.First] = (args[ArgIndexForUI.First] == false ?
                                        (
                                            args[ArgIndexForUI.First] == 0 ? Vector.Zero : 1
                                        )
                                        : 
                                        (
                                            args[ArgIndexForUI.First] == 1 ? " "         : 0
                                        )
                                    );

                                } else {
                                    UI[ArgIndexForUI.First].ValueForNonArg = (UI[ArgIndexForUI.First].ValueForNonArg == false ? 
                                        (
                                            UI[ArgIndexForUI.First].ValueForNonArg == 0 ? Vector.Zero : 1
                                        )
                                        :
                                        (
                                            UI[ArgIndexForUI.First].ValueForNonArg == 1 ? " "         : 0
                                        )
                                    );
                                } break;

                            //Do special actions                            
                            case UIType.Special: current.ActionForSpecialType.Invoke(incOrDec); break;
                            }

                        }
                //if current is not an arg
                //} else {
                //    SmallMessage(hp, "else fired!");
                //    UI[ArgIndexForUI.First].ValueForNonArg = !current.ValueForNonArg;
                //}
                UI[ArgIndexForUI.First].UpdateOverriddenText();
                updateInconstants(hp);
                break;
            
            //DecreaseByChange
            //case bindings[5].button:   changeSize += null; break;
        }
    }
}
Number countOfProjFX: GetAllEnumValues<ProjFX>().Length;
public String PFXToText(in ProjFX pfx)
{
    switch (pfx)
    {
        case ProjFX.BaptisteBioticLauncher:         return("Baptiste Biotic Launcher");         break;
        case ProjFX.BastionA36TacticalGrenade:      return("Bastion A36 Tactical Grenade");     break;
        case ProjFX.EchoStickyBomb:                 return("Echo Sticky Bomb");                 break;
        case ProjFX.GenjiShuriken:                  return("Genji Shuriken");                   break;
        case ProjFX.LucioSonicAmplifier:            return("Lucio Sonic Amplifier");            break;
        case ProjFX.MeiIcicle:                      return("Mei Icicle");                       break;
        case ProjFX.MercyCaduceusBlaster:           return("Mercy Caduceus Blaster");           break;
        case ProjFX.MoiraDamageOrb:                 return("Moira Damage Orb");                 break;
        case ProjFX.MoiraHealOrb:                   return("Moira Heal Orb");                   break;
        case ProjFX.OrbProjectile:                  return("Orb Projectile");                   break;
        case ProjFX.OrisaFusionDriver:              return("Orisa Fusion Driver");              break;
        case ProjFX.PharahRocket:                   return("Pharah Rocket");                    break;
        case ProjFX.RamattraRavenousVortexSphere:   return("Ramattra Ravenous Vortex Sphere");  break;
        case ProjFX.ReinhardtFireStrike:            return("Reinhardt Fire Strike");            break;
        case ProjFX.RoadhogScrap:                   return("Roadhog Scrap");                    break;
        case ProjFX.RoadhogScrapBall:               return("Roadhog Scrap Ball");               break;
        case ProjFX.SigmaHypersphere:               return("Sigma Hypersphere");                break;
        case ProjFX.SymmetraPhotonProjector:        return("Symmetra Photon Projector");        break;
        case ProjFX.ZaryaGraviton:                  return("Zarya Graviton");                   break;
        case ProjFX.ZaryaParticleCannon:            return("Zarya Particle Cannon");            break;
    }
}

rule: 'Switch heroes'
if ([Button.Crouch, Button.SecondaryFire].All(v => hp.IsButtonHeld(v)))
{
    SetAllowedHeroes(hp, AllHeroes().Remove(hp.Hero()));
    MinWait();
    SetAllowedHeroes(hp, AllHeroes());
}
rule: '[DEV] show values'
{
   //_CreateDevText($"index: {LocalPlayer().ArgIndexForUI.First}.{LocalPlayer().ArgIndexForUI[1]}");
   //_CreateDevText($"index of ext. pointer: {LocalPlayer().indexInExternalPointers}");
    //    String testString: <"<0><1><2>", Vector(1, 20, 300)[0], Vector(1, 20, 300)[1], Vector(1, 20, 300)[2]>;
    //    String VectorToString(in Vector vector): <"<0>", vector>;
    //String[] VectorComponentsToString(in Vector vector): [
    //    VectorToString(vector).Slice(1, VectorToString(vector).re())
    //];
   //CreateHudText(HostPlayer(), <"<0>", StringSplit(<"<0>", Vector(1, 20, 300)>, ", ")>, null, null, Location.Left, 1, Color.White, Color.White, Color.White, HudTextRev.VisibleToAndString, Spectators.DefaultVisibility);
   //_CreateDevText(testString);
   //_CreateDevText($"[0]: {split.First}, [1]: {split[1]}, [2]: {split[2]}]");
}
//ProjectileArgs args(in Player player=EventPlayer()): ProjectileArgs.Default(player);


//
//Exporting Codes
//


globalvar Player copyBot;
rule: 'Create bot for ui output'
{
    MinWait();
    CreateDummyBot(Hero.Soldier76, TeamOf(HostPlayer()), -1, Vector(0, 0, 0), null);
    copyBot = LastCreatedEntity();
    Wait(0.5);
    StartForcingPlayerPosition(copyBot, Vector(0, 0, 10), false);
    SetStatus(copyBot, null, Status.Unkillable, 999999999999);
    SetStatus(copyBot, null, Status.PhasedOut, 999999999999);
    StartForcingDummyBotName(copyBot, $"Copy Me! | Click the " + makeFG("fgff5555ff", "(x)") + " button");
}

globalvar Number[][] twoStepBooleanTimer = [];
Number TimeToTimeout: 0.75;
rule: 'Timeout TSB'
//The - n is how long it takes to timeout
if (twoStepBooleanTimer.Any(v => v[1] <= TotalTimeElapsed() - TimeToTimeout))
{
    Number[] current = twoStepBooleanTimer.Filter(v => v[1] <= TotalTimeElapsed() - TimeToTimeout).First;
    if (UI[current[0]].Value()) {
        if (UI[current[0]].IsArg) {
            hp._projArgs[current[0]] = true;
        } else {
            UI[current[0]].ValueForNonArg = true;
        }
    } else {
        if (UI[current[0]].IsArg) {
            hp._projArgs[current[0]] = false;
        } else {
            UI[current[0]].ValueForNonArg = false;
        }
    }
    UI[current[0]].UpdateOverriddenText();
    twoStepBooleanTimer = twoStepBooleanTimer.Filter(v => v.First != current.First);
    MinWait();
    LoopIfConditionIsTrue();
}

rule: 'Export code'
Event.OngoingPlayer
if (IsDummyBot())
if (UI[10].ValueForNonArg)
{
    SmallMessage(HostPlayer(), "   Exported! (Check Inspector)");
    updateInconstants();

    _projArgs = hp._projArgs;
    //argsInAnArray.ModAppend(HostPlayer()._projArgs);

    Wait(0.5);
    UI[10].ValueForNonArg = 0;
    UI[ArgIndexForUI.First].UpdateOverriddenText();
}


Vector ClampDirection(in Vector dir)
{
    return Vector(Clamp(dir.X, -1, 1), Clamp(dir.Y, -1, 1), Clamp(dir.Z, -1, 1));
}

Number Clamp(in Number value, in Number min, in Number max): Min(Max(value, min), max);