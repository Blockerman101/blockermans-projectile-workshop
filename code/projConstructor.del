//import "../../../Other/extraFunctions.ostw";
import "structs.del";
import "environmentCollision.del";
Vector | Number lerp2(in Vector | Number a, in Vector | Number b, in Number t, in Number tMax): ((tMax - t)/tMax)*a + (t/tMax)*b;
//lerp2(1, 5, 0.75, 1) = (1-0.75)*1 + (0.75)*5 = 0.25 + 3.75 = 4 "4 is 75% of the way from 1 to 5"
//lerp2(1, 5, 1, 2) = 1(2 - 1)/2 + 5(1/2) = 1(0.5) + 5(0.5) = 0.5 + 2.5 = 3 



globalvar Number lastProjectileID = 0;
globalvar ProjData[] projData = [ProjData.Construct()];
globalvar Number[] projData_VFX = [null];
globalvar ProjectileArgs[] projConstructor = [];
globalvar ProjectileArgs[] constructorData = [EmptyArray()];
globalvar TimeInInterval[] timeInInterval = [];

void CreateCustomProjectile(ProjectileArgs Args) "[BMPW] CreateProj Sub"
{
    //if (projData.Any(v => v.ProjState == projectileStates.Inactive))
    if (IsTrueForAny(projData.Map(v => v.ProjState), ArrayElement() == projectileStates.Inactive))
    {
        lastProjectileID = projData.Map(v => v.ProjState == projectileStates.Inactive ? CurrentArrayIndex() : false).Filter(v => v).First;
    }
    else
    {
        lastProjectileID = projData.Length;
    }
    //Args.ProjID = lastProjectileID;
    Args.ProjID = lastProjectileID;
    //LogToInspector($"Last ID: {lastProjectileID}");

    //projConstructor.ModAppend(Args); //omitted



    Any ID: Args.GetID();
    Number time: (TotalTimeElapsed() - projData[EvaluateOnce(ID)].TimeOfCreation);
    
    //Number rubberbandedTime: TotalTimeElapsed() - (0.016*11 * Args.Speed / 100);
    //experiment with this ^
    Number rubberbandedTime: TotalTimeElapsed();
    if (CountOf(Args)) //ensure projectile has info
    {
        Vector normalDir: Args.Direction.Normalize();
        ProjData data: {
            TimeOfCreation: rubberbandedTime, 
            RarelyChange: {
                Bezierp0: (Args.StartPosition), 
                Bezierp1: (Args.StartPosition) + (Args.Lifetime)*(Args.Speed * normalDir) * 0.5, 
                Bezierp2: (Args.StartPosition) + (Args.Lifetime)*(Args.Speed * normalDir) + (Args.Lifetime)^2 * (Args.Gravity / 2),
                RicochetCount: 0,
                temp: (-1 * Args.Speed * DotProduct(normalDir, Args.Gravity)/DotProduct(Args.Gravity, Args.Gravity))%interval
                }, 
            ProjState: projectileStates.Constructing, 
            ReadOnly: {
                Targets: Args.AffectedPlayers,
                Velocity: Args.Speed * normalDir.Normalize(),
                Gravity: Args.Gravity,
                }
            };

        projData[ID] = data;
        Number ProjTime: (TotalTimeElapsed() + Max(0, -1 * Args.Speed * DotProduct(normalDir, Args.Gravity)/DotProduct(Args.Gravity, Args.Gravity)));
        Number ProjTick: (((ProjTime%interval) / 0.016).Floor());
        TimeInInterval.Queue(ID, ProjTick);
        LogToInspector($"\nAdded to TII (ID: {ID})\nCurrentTick: {currentTick}, ProjTick: {ProjTick}\nCurrentIndex: {intervalIndex}, ProjIndex: {timeInInterval.Map(v => v.ID).IndexOf(ID)}]\n");
        if (timeInInterval.Length > 1 && currentTick > ProjTick) {LogToInspector($"Inc'd Index. (Index {timeInInterval.Map(v => v.ID).IndexOf(ID)} with ID {ID}, Index: {intervalIndex} -> {intervalIndex + 1})"); intervalIndex++;}
        CreateProjectileEffect(AllPlayers(), ProjectileType.BaptisteBioticLauncher, AllPlayers(), UpdateEveryFrame(projData[EvaluateOnce(ID)].Position), projData[EvaluateOnce(ID)].ReadOnly.Velocity + projData[EvaluateOnce(ID)].ReadOnly.Gravity * time, EvaluateOnce(Args.Oversize), ProjectileEffectReeval.PositionDirectionAndSize);
        projData_VFX[ID] = LastCreatedEntity();
        ProjDestructor.Queue(ID, Args.Lifetime);
    }
    else
    {
        LogToInspector("else fired");
    }
}

//Number maxTime: 3;

disabled rule: '[BMPW] Constructor - 1'
Event.OngoingGlobal
if (ConstructorQueued())
{
    //Wait(ServerLoadAverage()/512);
    ConstructorConstructor(1);
    Wait(ServerLoadAverage()/512);
    LoopIfConditionIsTrue();
}

disabled rule: '[BMPW] Constructor - 2'
Event.OngoingGlobal
if (ConstructorQueued())
{
    Wait(ServerLoadAverage()/512);
    ConstructorConstructor(2);
    Wait(ServerLoadAverage()/512);
    LoopIfConditionIsTrue();
}

disabled rule: '[BMPW] Constructor - 3'
Event.OngoingGlobal
if (ConstructorQueued())
{
    Wait(ServerLoadAverage()/512);
    ConstructorConstructor(3);
    Wait(ServerLoadAverage()/512);
    LoopIfConditionIsTrue();
}

disabled rule: '[BMPW] Constructor - 4'
Event.OngoingGlobal
if (ConstructorQueued())
{
    Wait(ServerLoadAverage()/512);
    ConstructorConstructor(4);
    Wait(ServerLoadAverage()/512);
    LoopIfConditionIsTrue();
}


disabled rule: '[BMPW] Constructor - 5'
Event.OngoingGlobal
if (ConstructorQueued())
{
    Wait(ServerLoadAverage()/512);
    ConstructorConstructor(5);
    Wait(ServerLoadAverage()/512);
    LoopIfConditionIsTrue();
}

Any ConstructorQueued(): projConstructor.Length;
//ref ProjectileArgs Args
void ConstructorConstructor(Number constructorID) "Projectile Constructor"
{

    ProjectileArgs Args: constructorData[constructorID];
    Any ID: Args.GetID();
    Number time: (TotalTimeElapsed() - projData[EvaluateOnce(ID)].TimeOfCreation);
    
    //Number rubberbandedTime: TotalTimeElapsed() - (0.016*11 * Args.Speed / 100);
    //experiment with this ^
    Number rubberbandedTime: TotalTimeElapsed();

    constructorData[constructorID] = projConstructor.First; //set data
    projConstructor.ModRemoveByIndex(0); //truncate projConstructor
    if (CountOf(Args)) //ensure projectile has info
    {
        Vector normalDir: Args.Direction.Normalize();
        ProjData data: {
            TimeOfCreation: rubberbandedTime, 
            RarelyChange: {
                Bezierp0: (Args.StartPosition), 
                Bezierp1: (Args.StartPosition) + (Args.Lifetime)*(Args.Speed * normalDir) * 0.5, 
                Bezierp2: (Args.StartPosition) + (Args.Lifetime)*(Args.Speed * normalDir) + (Args.Lifetime)^2 * (Args.Gravity / 2),
                RicochetCount: 0,
                temp: (-1 * Args.Speed * DotProduct(normalDir, Args.Gravity)/DotProduct(Args.Gravity, Args.Gravity))%interval
                }, 
            ProjState: projectileStates.Constructing, 
            ReadOnly: {
                Targets: Args.AffectedPlayers,
                Velocity: Args.Speed * normalDir,
                Gravity: Args.Gravity,
                }
            };

        projData[ID] = data;
        Number ProjTime: (TotalTimeElapsed() + Max(0, -1 * Args.Speed * DotProduct(normalDir, Args.Gravity)/DotProduct(Args.Gravity, Args.Gravity)));
        Number ProjTick: (((ProjTime%interval) / 0.016).Floor());
        TimeInInterval.Queue(ID, ProjTick);
        LogToInspector($"\nAdded to TII (ID: {ID})\nCurrentTick: {currentTick}, ProjTick: {ProjTick}\nCurrentIndex: {intervalIndex}, ProjIndex: {timeInInterval.Map(v => v.ID).IndexOf(ID)}]\n");
        if (timeInInterval.Length > 1 && currentTick > ProjTick) {LogToInspector($"Inc'd Index. (Index {timeInInterval.Map(v => v.ID).IndexOf(ID)} with ID {ID}, Index: {intervalIndex} -> {intervalIndex + 1})"); intervalIndex++;}
        CreateProjectileEffect(AllPlayers(), ProjectileType.BaptisteBioticLauncher, AllPlayers(), UpdateEveryFrame(projData[EvaluateOnce(ID)].Position), projData[EvaluateOnce(ID)].ReadOnly.Velocity + projData[EvaluateOnce(ID)].ReadOnly.Gravity * time, EvaluateOnce(Args.Oversize), ProjectileEffectReeval.PositionDirectionAndSize);
        projData_VFX[ID] = LastCreatedEntity();
        ProjDestructor.Queue(ID, Args.Lifetime);
    }
    else
    {
        LogToInspector("else fired");
    }
}