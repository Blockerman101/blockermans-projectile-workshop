import "BMPW/structs.del";
import "../../../Other/extraFunctions.ostw";
import "tx.del";

single struct ProjArgData
{
    //The corresponding index in ProjectileArgs
    public Number Pointer;
    //Whether this arg is used internally, or can be set by the player
    public Boolean Internal;

    //Whether the default value for this arg is constant. ex. startPos = Eye Position is not constant, speed = 20 is
    public Boolean DefaultIsConstant;
    public String TextForArg;
    public String TextForValue;
    public String TextForNotConstantDefault;
    public Any Arg(in Player player=EventPlayer()): args(player)[this.Pointer];
    

    public static ProjArgData Construct(): {
        Pointer: null,
        Internal: true,
        DefaultIsConstant: false,
        TextForArg: null,
        TextForValue: null,
        TextForNotConstantDefault: ""
    };
}

struct ProjArgDataForUI
{
    public ProjArgData[] data;
    //public Any Arg: ;
    //public Number Pointer: ;
}

//"_ProjID",
//"Proj FX",
//"Start Position",
//"Direction",
//"Targets",
//"Oversize",
//"Speed",
//"Lifetime",
//"Gravity",
//"_TimeOfCall",
globalvar ProjArgData[] projArgDataForUI = [
    //data: [
        //_ProjID
        {
            Pointer: 0,
            Internal: true,
            DefaultIsConstant: false,
            //TextForArg: "_ProjID",
            ..ProjArgData.Construct()
        },

        //ProjFX
        {
            Pointer: 1,
            Internal: false,
            DefaultIsConstant: true,
            TextForArg: "Proj FX",
            TextForValue: $"{PFXToText(args()[1])} ({args()[1]})",
            ..ProjArgData.Construct()
        },

        //StartPosition
        {
            Pointer: 2,
            Internal: false,
            DefaultIsConstant: false,
            TextForArg: "Start Position",
            TextForNotConstantDefault: "Eye Position(EP)",

            ..ProjArgData.Construct()
        },

        //Direction
        {
            Pointer: 3,
            Internal: false,
            DefaultIsConstant: false,
            TextForArg: "Direction",
            TextForNotConstantDefault: "Facing Dir(EP)",
            ..ProjArgData.Construct()
        },

        //Targets
        {
            Pointer: 4,
            Internal: false,
            DefaultIsConstant: false,
            TextForArg: "Targets",
            TextForNotConstantDefault: "All Players(Opp Team(Team(EP)))",
            ..ProjArgData.Construct()
        },

        //Oversize
        {
            Pointer: 5,
            Internal: false,
            DefaultIsConstant: true,
            TextForArg: "Oversize",
            ..ProjArgData.Construct()
        },
        //Speed
        {
            Pointer: 6,
            Internal: false,
            DefaultIsConstant: true,
            TextForArg: "Speed",
            ..ProjArgData.Construct()
        },
        
        //Lifetime
        {
            Pointer: 7,
            Internal: false,
            DefaultIsConstant: true,
            TextForArg: "Lifetime",
            ..ProjArgData.Construct()
        },
        
        //Gravity
        {
            Pointer: 8,
            Internal: false,
            DefaultIsConstant: true,
            TextForArg: "Gravity",
            ..ProjArgData.Construct()
        },
        
        //_TimeOfCall
        {
            Pointer: 9,
            Internal: true,
            DefaultIsConstant: false,
            //TextForArg: "_TimeOfCall",
            ..ProjArgData.Construct()
        }
        
    ];
//};

single struct ActionsForUIPress
{
    public Button button;
    public String toString: InputBindingString(this.button);
}
ActionsForUIPress[] bindings: [
    //Down
    {
        button: Button.Crouch
    },

    //Up
    {
        button: Button.Jump
    },

    //IncreaseChange
    {
        button: Button.Ability2
    },

    //DecreaseChange
    {
        button: Button.Ability1
    },

    //IncreaseByChange
    {
        button: Button.PrimaryFire
    },

    //DecreaseByChange
    {
        button: Button.SecondaryFire
    }

];
playervar Boolean editingArgs;
playervar Number changeSize = 1;
playervar Number[] ArgIndexForUI;

rule: '[BMPW] Create text showing proj args'
//if (ProjArgDataForUI.Keys.Length)
{
    Player lp: LocalPlayer();
    Wait(0.5);
    CreateHudText(VisibleTo: LocalPlayer(),
        Header: $"Press {InputBindingString(Button.Crouch)} + {InputBindingString(Button.Interact)} to change args",
        Location: Location.Left, SortOrder: -1, Reevaluation: HudTextRev.VisibleToAndString, Spectators: Spectators.DefaultVisibility);
    CreateHudText(VisibleTo: LocalPlayer(),
        Header: !lp.editingArgs ? "" : $"Down: {bindings[0].toString} | Up: {bindings[1].toString}\nSize: {lp.changeSize} | Increase Change: {bindings[2].toString} | Decrease Change: {bindings[3].toString}\nIncrease By Change: {bindings[4].toString} | Decrease By Change: {bindings[5].toString}",
        Location: Location.Left, SortOrder: -1, Reevaluation: HudTextRev.VisibleToAndString, Spectators: Spectators.DefaultVisibility);
    for (_waitlessIterator = 0; _waitlessIterator < projArgDataForUI.Length; _waitlessIterator++)
    {
        Number i: _waitlessIterator;
        Number ie: EvaluateOnce(i);
        ProjArgData value: projArgDataForUI[ie];
        if (!projArgDataForUI[i].Internal)
        {
            CreateHudText(
                VisibleTo: LocalPlayer(),
                //Header: $"Press {InputBindingString(Button.Crouch)} + {InputBindingString(Button.Interact)} to change args",
                Subheader: null,
                Text: $"{value.TextForArg}: {value.DefaultIsConstant ? (value.TextForValue ? value.TextForValue : value.Arg(lp)) : value.TextForNotConstantDefault}" + 
                (lp.ArgIndexForUI.First != value.Pointer ? "" : makeFG("fgFF0000FF", "<")),
                Location: Location.Left,
                SortOrder: -1,
                //HeaderColor: ,
                //SubheaderColor: ,
                //TextColor: ,
                Reevaluation: HudTextRev.VisibleToAndString,
                Spectators: Spectators.DefaultVisibility
            );
        }
    }
}


rule: 'toggle editing args & process inputs'
Event.OngoingPlayer
if ((bindings.Any(v => IsButtonHeld(EventPlayer(), v.button)) && editingArgs) || (IsButtonHeld(EventPlayer(), Button.Crouch) && IsButtonHeld(EventPlayer(), Button.Interact)))
{   
    //SmallMessage(HostPlayer(), "rule fired");
    //XOR
    Button[] buttonsHeld = bindings.Map(v => v.button).Filter(v => IsButtonHeld(EventPlayer(), v));
    Number numberOfButtonsForTogglingEditingPressed: [Button.Crouch, Button.Interact].Filter(v => IsButtonHeld(EventPlayer(), v)).Length;
    if (numberOfButtonsForTogglingEditingPressed == 1) {
        //Gives player 1 second to do keystrokes for toggling editing args
        WaitUntil(numberOfButtonsForTogglingEditingPressed != 1, 1);
    }

    if (IsButtonHeld(EventPlayer(), Button.Crouch) && IsButtonHeld(EventPlayer(), Button.Interact)) {
        editingArgs = !editingArgs;
        //toggle bindings
            for (_waitlessIterator = 0; _waitlessIterator < bindings.Length; _waitlessIterator++) {
        if (editingArgs) {
            DisallowButton(EventPlayer(), bindings[_waitlessIterator].button);
        } else {
            AllowButton(EventPlayer(), bindings[_waitlessIterator].button);
        }
        }
    } else if (editingArgs) {
        //SmallMessage(HostPlayer(), "switched!");
        switch (buttonsHeld.First)
        {
            //Down
            case bindings[0].button:   ArgIndexForUI[0] += 1; break;
            
            //Up
            case bindings[1].button:   ArgIndexForUI[0] -= 1; break;
            
            //IncreaseChange
            case bindings[2].button:   changeSize *= 10;   break;
            
            //DecreaseChange
            case bindings[3].button:   changeSize /= 10;   break;
            
            //IncreaseByChange
            case bindings[4].button:   changeSize += null; break;
            
            //DecreaseByChange
            case bindings[5].button:   changeSize += null; break;
        }
    }
}

rule: '[DEV] show values'
{
   _CreateDevText($"index: {LocalPlayer().ArgIndexForUI.First}");
}


playervar ProjectileArgs _projArgs;
ProjectileArgs args(in Player player=EventPlayer()): ProjectileArgs.Default(player);
ProjectileArgs defaultArgs: ProjectileArgs.Default();
globalvar Player copyBot;
rule: 'Create bot for ui output'
{
    CreateDummyBot(Hero.Soldier76, TeamOf(HostPlayer()), -1, Vector(0, 999, 0), null);
    copyBot = LastCreatedEntity();
    StartForcingPlayerPosition(copyBot, Vector(0, 999, 0), false);
    SetStatus(copyBot, null, Status.Unkillable, 999999999999);
    SetStatus(copyBot, null, Status.PhasedOut, 999999999999);
    StartForcingDummyBotName(copyBot, "Copy Me!");
}

private String PFXToText(in ProjFX pfx)
{
    switch (pfx)
    {
        case ProjFX.BaptisteBioticLauncher:         return("Baptiste Biotic Launcher");         break;
        case ProjFX.BastionA36TacticalGrenade:      return("Bastion A36 Tactical Grenade");     break;
        case ProjFX.EchoStickyBomb:                 return("Echo Sticky Bomb");                 break;
        case ProjFX.GenjiShuriken:                  return("Genji Shuriken");                   break;
        case ProjFX.LucioSonicAmplifier:            return("Lucio Sonic Amplifier");            break;
        case ProjFX.MeiIcicle:                      return("Mei Icicle");                       break;
        case ProjFX.MercyCaduceusBlaster:           return("Mercy Caduceus Blaster");           break;
        case ProjFX.MoiraDamageOrb:                 return("Moira Damage Orb");                 break;
        case ProjFX.MoiraHealOrb:                   return("Moira Heal Orb");                   break;
        case ProjFX.OrbProjectile:                  return("Orb Projectile");                   break;
        case ProjFX.OrisaFusionDriver:              return("Orisa Fusion Driver");              break;
        case ProjFX.PharahRocket:                   return("Pharah Rocket");                    break;
        case ProjFX.RamattraRavenousVortexSphere:   return("Ramattra Ravenous Vortex Sphere");  break;
        case ProjFX.ReinhardtFireStrike:            return("Reinhardt Fire Strike");            break;
        case ProjFX.RoadhogScrap:                   return("Roadhog Scrap");                    break;
        case ProjFX.RoadhogScrapBall:               return("Roadhog Scrap Ball");               break;
        case ProjFX.SigmaHypersphere:               return("Sigma Hypersphere");                break;
        case ProjFX.SymmetraPhotonProjector:        return("Symmetra Photon Projector");        break;
        case ProjFX.ZaryaGraviton:                  return("Zarya Graviton");                   break;
        case ProjFX.ZaryaParticleCannon:            return("Zarya Particle Cannon");            break;
    }
}