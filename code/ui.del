import "BMPW/structs.del";
import "../../../Other/extraFunctions.ostw";
import "tx.del";
//import "mynewfile.del";

enum UIType
{
    NULL,
    Number,
    Vector,
    Boolean,
    ProjFX
}

single struct ProjArgData
{
    //The corresponding index in ProjectileArgs
    public Number Pointer;
    //Whether this arg is used internally, or can be set by the player
    public Boolean Internal;
    public UIType UIType;
    //Whether the default value for this arg is constant. ex. startPos = Eye Position is not constant, speed = 20 is
    public Boolean DefaultIsConstant;
    public String TextForArg;
    public String TextForValue;
    public String TextForNotConstantDefault;
    //Whether this current arg is an actual member of projArg, or just another option for the UI
    public Boolean IsArg;
    //public Any Arg(in Player player=EventPlayer()): args(player)[this.Pointer];
    public Any Arg(in Player player=EventPlayer()): player._projArgs[this.Pointer];
    

    public static ProjArgData Construct(): {
        Pointer: null,
        Internal: true,
        UIType: UIType.NULL,
        DefaultIsConstant: false,
        TextForArg: null,
        TextForValue: null,
        TextForNotConstantDefault: "",
        IsArg: true
    };
}

//struct ProjArgDataForUI
//{
//    public ProjArgData[] data;
//    //public Any Arg: ;
//    //public Number Pointer: ;
//    public void 
//}



//"_ProjID",
//"Proj FX",
//"Start Position",
//"Direction",
//"Targets",
//"Oversize",
//"Speed",
//"Lifetime",
//"Gravity",
//"_TimeOfCall",

ProjectileArgs args(in Player player=EventPlayer()): player._projArgs;
playervar ProjectileArgs _projArgs = ProjectileArgs.Default();

void updateNotConstants(in Player player=EventPlayer()) {
  for (_waitlessIterator = 0; _waitlessIterator < CountOf(player._projArgs); _waitlessIterator++)
  {
    if (!projArgDataForUI[_waitlessIterator].DefaultIsConstant) {
        player._projArgs[_waitlessIterator] = ProjectileArgs.Default()[_waitlessIterator];
    }
  }   
}

//Should be playervar because of things involving TextForValue
playervar ProjArgData[] projArgDataForUI = [
    //data: [
        //_ProjID
        {
            Pointer: 0,
            Internal: true,
            DefaultIsConstant: false,
            //TextForArg: "_ProjID",
            ..ProjArgData.Construct()
        },


        //ProjFX
        {
            Pointer: 1,
            Internal: false,
            UIType: UIType.ProjFX,
            DefaultIsConstant: true,
            TextForArg: "Proj FX",
            //THE TROUBLEMAKER
            TextForValue: <"<0> (<1>)", PFXToText(_projArgs.ProjFX), _projArgs.ProjFX>,
            //TextForValue: $"{_mytestvar.MyField}",
            ..ProjArgData.Construct()
        },

        //StartPosition
        {
            Pointer: 2,
            Internal: false,
            UIType: UIType.Vector,
            DefaultIsConstant: false,
            TextForArg: "Start Position",
            TextForNotConstantDefault: "Eye Position(EP)",
            ..ProjArgData.Construct()
        },
        //Direction
        {
            Pointer: 3,
            Internal: false,
            UIType: UIType.Vector,
            DefaultIsConstant: false,
            TextForArg: "Direction",
            TextForNotConstantDefault: "Facing Dir(EP)",
            ..ProjArgData.Construct()
        },

        //Targets
        {
            Pointer: 4,
            Internal: false,
            DefaultIsConstant: false,
            TextForArg: "Targets",
            TextForNotConstantDefault: "All Players(Opp Team(Team(EP)))",
            ..ProjArgData.Construct()
        },

        //Oversize
        {
            Pointer: 5,
            Internal: false,
            UIType: UIType.Number,
            DefaultIsConstant: true,
            TextForArg: "Oversize",
            ..ProjArgData.Construct()
        },
        //Speed
        {
            Pointer: 6,
            Internal: false,
            UIType: UIType.Number,
            DefaultIsConstant: true,
            TextForArg: "Speed",
            ..ProjArgData.Construct()
        },
        
        //Lifetime
        {
            Pointer: 7,
            Internal: false,
            UIType: UIType.Number,
            DefaultIsConstant: true,
            TextForArg: "Lifetime",
            ..ProjArgData.Construct()
        },
        
        //Gravity
        {
            Pointer: 8,
            Internal: false,
            UIType: UIType.Vector,
            DefaultIsConstant: true,
            TextForArg: "Gravity",
            ..ProjArgData.Construct()
        },
        
        //_TimeOfCall
        {
            Pointer: 9,
            Internal: true,
            DefaultIsConstant: false,
            //TextForArg: "_TimeOfCall",
            ..ProjArgData.Construct()
        }
        
    ];
//};

single struct ActionsForUIPress
{
    public Button button;
    public String toString: InputBindingString(this.button);
}
ActionsForUIPress[] bindings: [
    //Down
    {
        button: Button.Crouch
    },

    //Up
    {
        button: Button.Jump
    },

    //IncreaseChange
    {
        button: Button.Ability2
    },

    //DecreaseChange
    {
        button: Button.Ability1
    },

    //IncreaseByChange
    {
        button: Button.PrimaryFire
    },

    //DecreaseByChange
    {
        button: Button.SecondaryFire
    }

];
playervar Boolean editingArgs;
playervar Number changeSize = 1;
playervar Number[] ArgIndexForUI = [externalPointers.First];


rule: '[BMPW] Create text showing proj args'
if (AllPlayers())
if (AllPlayers().First.projArgDataForUI.Length)
{
    Player lp: LocalPlayer();
    Wait(4);
    CreateHudText(VisibleTo: LocalPlayer(),
        Header: $"Press {makeFG('fg55FF55FF', InputBindingString(Button.Interact))} to fire projectile!\nPress {InputBindingString(Button.Crouch)} + {InputBindingString(Button.Interact)} to start/stop changing args",
        Location: Location.Left, SortOrder: -1, Reevaluation: HudTextRev.VisibleToAndString, Spectators: Spectators.DefaultVisibility);
    String colorForBindings: 'fg7777FFFF';
    CreateHudText(VisibleTo: LocalPlayer(),
        Header: !lp.editingArgs ? "" : $"Down: {makeFG(colorForBindings, bindings[0].toString)} | Up: {makeFG(colorForBindings, bindings[1].toString)}\nIncrease Change: {makeFG(colorForBindings, bindings[2].toString)} | Decrease Change: {makeFG(colorForBindings, bindings[3].toString)}\nIncrease By Change: {makeFG(colorForBindings, bindings[4].toString)} | Decrease By Change: {makeFG(colorForBindings, bindings[5].toString)}",
        Location: Location.Left, SortOrder: -1, Reevaluation: HudTextRev.VisibleToAndString, Spectators: Spectators.DefaultVisibility);
    for (_waitlessIterator = 0; _waitlessIterator < AllPlayers().First.projArgDataForUI.Length; _waitlessIterator++)
    {
        Number i: _waitlessIterator;
        Number ie: EvaluateOnce(i);
        ProjArgData value: lp.projArgDataForUI[ie];
        //Split into 3 different strings, 1 for each vector component
        
        String[] valueToSplitVectorString: [<"<0>", XOf(args(lp)[value.Pointer])>, <"<0>", YOf(args(lp)[value.Pointer])>, <"<0>", ZOf(args(lp)[value.Pointer])>];
        Any addPointer: (lp.ArgIndexForUI.First != value.Pointer || !lp.editingArgs ? "" : makeFG("fgFF0000FF", $"←±{lp.changeSize}"));
        
        if (!AllPlayers().First.projArgDataForUI[i].Internal)
        {
            CreateHudText(
                VisibleTo: LocalPlayer(),
                //Header: $"Press {InputBindingString(Button.Crouch)} + {InputBindingString(Button.Interact)} to change args",
                Subheader: null,
                Text:
                    $"{value.TextForArg}: " + 
                    ((value.UIType != UIType.Vector || (!value.DefaultIsConstant)) ? 
                        $"{value.DefaultIsConstant ? (value.TextForValue ? value.TextForValue : args(lp)[value.Pointer]) : value.TextForNotConstantDefault}" + addPointer
                    :
                        "(" + valueToSplitVectorString.First + ((lp.ArgIndexForUI.First == value.Pointer && lp.ArgIndexForUI[1] == (0)) && lp.editingArgs ? makeFG("fgFF0000FF", $"←±{lp.changeSize}") : "") + 
                        ", " + valueToSplitVectorString[1]   + ((lp.ArgIndexForUI.First == value.Pointer && lp.ArgIndexForUI[1] == (1)) && lp.editingArgs ? makeFG("fgFF0000FF", $"←±{lp.changeSize}") : "") + 
                        ", " + valueToSplitVectorString[2]   + ((lp.ArgIndexForUI.First == value.Pointer && lp.ArgIndexForUI[1] == (2)) && lp.editingArgs ? makeFG("fgFF0000FF", $"←±{lp.changeSize}") : "") +
                        ")"
                    )
                
                ,

                Location: Location.Left,
                SortOrder: -1,
                //HeaderColor: ,
                //SubheaderColor: ,
                //TextColor: ,
                Reevaluation: HudTextRev.VisibleToAndString,
                Spectators: Spectators.DefaultVisibility
            );
        }
    }
}


Number[] externalPointers: projArgDataForUI.Filter(v => !v.Internal).Map(v => v.Pointer);
playervar Number indexInExternalPointers = 0;

rule: 'toggle editing args & process inputs'
Event.OngoingPlayer
if ((bindings.Any(v => IsButtonHeld(EventPlayer(), v.button)) && editingArgs) || (IsButtonHeld(EventPlayer(), Button.Crouch) && IsButtonHeld(EventPlayer(), Button.Interact)))
{   
    //SmallMessage(HostPlayer(), "rule fired");
    Button[] buttonsHeld = bindings.Map(v => v.button).Filter(v => IsButtonHeld(EventPlayer(), v));
    Number numberOfButtonsForTogglingEditingPressed: [Button.Crouch, Button.Interact].Filter(v => IsButtonHeld(EventPlayer(), v)).Length;

    
    
    //XOR
    if (numberOfButtonsForTogglingEditingPressed == 1) {
        //Gives player 1 second to do keystrokes for toggling editing args
        WaitUntil(numberOfButtonsForTogglingEditingPressed != 1, 1);
    }

    if (IsButtonHeld(EventPlayer(), Button.Crouch) && IsButtonHeld(EventPlayer(), Button.Interact)) {
        editingArgs = !editingArgs;
        //toggle bindings
            for (_waitlessIterator = 0; _waitlessIterator < bindings.Length; _waitlessIterator++) {
        if (editingArgs) {
            DisallowButton(EventPlayer(), bindings[_waitlessIterator].button);
        } else {
            AllowButton(EventPlayer(), bindings[_waitlessIterator].button);
        }
        }
    } else if (editingArgs) {
        //SmallMessage(HostPlayer(), "switched!");

        //The currently selected arg
        ProjArgData current: projArgDataForUI[ArgIndexForUI.First];

        switch (buttonsHeld.First)
        {
            //Down
            case bindings[0].button:   if (projArgDataForUI[ArgIndexForUI.First].UIType == UIType.Vector && ArgIndexForUI[1] < 2 && projArgDataForUI[ArgIndexForUI.First].DefaultIsConstant) {
                    ArgIndexForUI[1] += 1;
                } else {
                    indexInExternalPointers = (indexInExternalPointers + 1)%(externalPointers.Length);
                    //Traverse to the next external pointer (circular)
                    ArgIndexForUI[0] = externalPointers[indexInExternalPointers];
                    //ArgIndexForUI[0] += 1;
                    ArgIndexForUI[1] = 0;
                } break;
            
            //Up
            case bindings[1].button:   if (projArgDataForUI[ArgIndexForUI.First].UIType == UIType.Vector && ArgIndexForUI[1] > 0 && projArgDataForUI[ArgIndexForUI.First].DefaultIsConstant) {
                    ArgIndexForUI[1] -= 1;
                } else {
                    indexInExternalPointers = !indexInExternalPointers ? externalPointers.Length - 1 : (indexInExternalPointers - 1)%(externalPointers.Length);
                    //Traverse to the previous external pointer (circular)
                    ArgIndexForUI[0] = externalPointers[indexInExternalPointers];
                    //ArgIndexForUI[0] -= 1;
                    ArgIndexForUI[1] = 2;
                } break;
            
            //IncreaseChange
            case bindings[2].button:   changeSize *= 10;   break;
            
            //DecreaseChange
            case bindings[3].button:   changeSize /= 10;   break;
            
            Number incOrDec: (buttonsHeld.First == bindings[4].button ? 1 : -1);
            //IncreaseByChange || DecreaseByChange
            case bindings[4].button:
            case bindings[5].button: 
            if (current.DefaultIsConstant) {
                switch(current.UIType) {
                    //If type -> if increase button is held, increase, else, decrease
                    case UIType.Number: EventPlayer()._projArgs[ArgIndexForUI.First] += changeSize * incOrDec; break;

                    //Switch through the diff components
                    case UIType.Vector: {
                        //the different indexes/components of a vector (0 = x, 1 = y, 2 = z)
                        switch (ArgIndexForUI[1]) {
                            case 0: EventPlayer()._projArgs[ArgIndexForUI.First] += Vector(changeSize, 0, 0) * incOrDec; break;
                            case 1: EventPlayer()._projArgs[ArgIndexForUI.First] += Vector(0, changeSize, 0) * incOrDec; break;
                            case 2: EventPlayer()._projArgs[ArgIndexForUI.First] += Vector(0, 0, changeSize) * incOrDec; break;
                        }
                    } break;

                    //Flip booleans
                    case UIType.Boolean: EventPlayer()._projArgs[ArgIndexForUI.First] = !EventPlayer()._projArgs[ArgIndexForUI.First]; break;

                    //Special type, for the ProjFX arg. From index 0 through 19, then loop back to 0
                    case UIType.ProjFX:
                        //circular adding
                        if (buttonsHeld.First == bindings[4].button) {
                            
                            EventPlayer()._projArgs[ArgIndexForUI.First] = (EventPlayer()._projArgs[ArgIndexForUI.First] + 1)%countOfProjFX;
                        }
                        //circular subtracting
                        else {
                            EventPlayer()._projArgs[ArgIndexForUI.First] -= 1;
                            if (EventPlayer()._projArgs[ArgIndexForUI.First] < 0) {EventPlayer()._projArgs[ArgIndexForUI.First] = countOfProjFX - 1 - EventPlayer()._projArgs[ArgIndexForUI.First];}
                        }
                        break;
                }
            } break;
            
            //DecreaseByChange
            //case bindings[5].button:   changeSize += null; break;
        }
    }
}


rule: '[DEV] show values'
{
   //_CreateDevText($"index: {LocalPlayer().ArgIndexForUI.First}.{LocalPlayer().ArgIndexForUI[1]}");
   //_CreateDevText($"index of ext. pointer: {LocalPlayer().indexInExternalPointers}");
    //    String testString: <"<0><1><2>", Vector(1, 20, 300)[0], Vector(1, 20, 300)[1], Vector(1, 20, 300)[2]>;
    //    String VectorToString(in Vector vector): <"<0>", vector>;
    //String[] VectorComponentsToString(in Vector vector): [
    //    VectorToString(vector).Slice(1, VectorToString(vector).re())
    //];
   //CreateHudText(HostPlayer(), <"<0>", StringSplit(<"<0>", Vector(1, 20, 300)>, ", ")>, null, null, Location.Left, 1, Color.White, Color.White, Color.White, HudTextRev.VisibleToAndString, Spectators.DefaultVisibility);
   //_CreateDevText(testString);
   //_CreateDevText($"[0]: {split.First}, [1]: {split[1]}, [2]: {split[2]}]");
}
//ProjectileArgs args(in Player player=EventPlayer()): ProjectileArgs.Default(player);