//import "../../../Other/extraFunctions.ostw";
import "structs.del";
import "simpleProcessing.del";
Vector | Number lerp2(in Vector | Number a, in Vector | Number b, in Number t, in Number tMax): ((tMax - t)/tMax)*a + (t/tMax)*b;
//lerp2(1, 5, 0.75, 1) = (1-0.75)*1 + (0.75)*5 = 0.25 + 3.75 = 4 "4 is 75% of the way from 1 to 5"
//lerp2(1, 5, 1, 2) = 1(2 - 1)/2 + 5(1/2) = 1(0.5) + 5(0.5) = 0.5 + 2.5 = 3 



globalvar Number lastProjectileID = 0;
globalvar ProjData[] projData = [ProjData.Construct()];
//globalvar (Number|Number[])[] projData_VFX = [null];
globalvar ProjectileArgs[] projConstructor = [];
//globalvar ProjectileArgs[] constructorData = [EmptyArray()];  //This var isnt be needed with 1 constructor, you can just ref `projConstructor.First`
globalvar TimeInInterval[] timeInInterval = [];

void CreateCustomProjectile(ProjectileArgs Args) "[BMPW] CreateProj Sub"
{
    //if (projData.Any(v => v.ProjState == ProjState.Inactive))
    if (IsTrueForAny(projData.Map(v => v.ProjState), ArrayElement() == ProjState.Inactive)) //Make new lastProjID
    {
        lastProjectileID = projData.Map(v => v.ProjState == ProjState.Inactive ? CurrentArrayIndex() : false).Filter(v => v).First;
    }
    else
    {
        lastProjectileID = projData.Length;
    }
    //Args.ProjID = lastProjectileID;
    Args._SetID(lastProjectileID);
    Args._SetTOC(tte);
    projData[lastProjectileID].ProjState = ProjState.NULL; //setting a projstate value so `lastProjectileID = projData.Length` increments correctly with >1 proj in a single tick
    

    //LogToInspector($"Last ID: {lastProjectileID}");
    projConstructor.ModAppend(Args); //Add this proj call to the construction queue

    //DEV
    //Args = null;
}

rule: '[BMPW] Constructor'
Event.OngoingGlobal
if (projConstructor.Length > 0)
{

    //LogToInspector("Constructor Fired!");
    ProjectileArgs Args: projConstructor.First;
    Any ID: Args._GetID();

    //deltaT is not the time since the last tick, but the time that passed since this proj was called
    //This is useful because instead of making the projectile at the current time, I can buffer it to act as if it was created at its time of call
    Number deltaTMax: 0.5;
    //This also kind of updates (because its a macro), so it doesnt need to be reevaled manually after waits
    Number deltaT: Min(deltaTMax, tte - Args._GetTOC()); 
    //Number deltaT: 0.45;
    //LogToInspector($"proj {ID} has {Args.Lifetime}s LT and {deltaT} deltaT");
    
    //ensure projectile has info
    if (CountOf(Args)) 
    {

        //dataAdd -> TII add -> first ED -> first SD -> WAIT

        //Normalize dir internally (redundancy) //For reference, if you do .First instead of [0] OSTW throws an error
        projConstructor[0].Direction = projConstructor[0].Direction.Normalize();

        //Make speed have min of 0
        projConstructor[0].Speed = Max(0, projConstructor[0].Speed);

        //Number buffer: (deltaT + 0.016*2 + (ServerLoadPeak() >= 200 ? 0.032 : 0.016));
        projData[ID] = <ProjData> {
            //This is used as the reference for other time-based values, so by modifying this, you modify everything else
            //The lower this value is, the greater the time/position is
            //the 0.016*18 buffer is because of a weird bug involving TTE with createFX/createProjFX. Since TTE is referenced twice in the position macro, the TimeOfCreation needs to be buffered by 9 ticks, twice (0.288 = 0.016*9*2)
            
            //TimeOfCreation:  Args._GetTOC() - buffer - (ServerLoadAverage() >= 200 ? 0.032 : 0.016),
            TimeOfCreation: Args._GetTOC() - deltaT,
            
            //RarelyChange: {
            //    Bezierp0: (Args.StartPosition), 
            //    Bezierp1: (Args.StartPosition) + (Args.Lifetime)*(Args.Speed * Args.Direction) * 0.5, 
            //    Bezierp2: (Args.StartPosition) + (Args.Lifetime)*(Args.Speed * Args.Direction) + (Args.Lifetime)^2 * (Args.Gravity / 2),
            //    }, 

            ProjState: ProjState.Active, 

            ReadOnly: {
                InitPos: Args.StartPosition,
                Radius: 0,
                Targets: Args.Targets,
                Velocity: Args.Speed * Args.Direction,
                Gravity: Args.Gravity,
                VFX: null
                },

            //this is for testing, not intended for user
            HitPlayer: null
        };

        Number timeToMaxHeight: (tte + Max(0, -1 * Args.Speed * DotProduct(Args.Direction, Args.Gravity)/DotProduct(Args.Gravity, Args.Gravity)));
        Number ticksToMaxHeight: (((timeToMaxHeight%interval) / 0.016).Floor());
        TimeInInterval.Queue(ID, ticksToMaxHeight);
        LogToInspector($"\nAdded to TII (ID: {ID})\nCurrentTick: {currentTick}, ProjTick: {ticksToMaxHeight}\nCurrentIndex: {intervalIndex}, ProjIndex: {timeInInterval.Map(v => v.ID).IndexOf(ID)}]\n");
        if (timeInInterval.Length > 1 && currentTick >= ticksToMaxHeight) {
            //LogToInspector($"Inc'd Index. (Index {timeInInterval.Map(v => v.ID).IndexOf(ID)} with ID {ID}, Index: {intervalIndex} -> {intervalIndex + 1})"); 
            intervalIndex++;
        }

        //first ED Check
        Number ModdedTimeToMaxHeight: Max(0, -1 * Args.Speed * DotProduct(Args.Direction, Args.Gravity)/DotProduct(Args.Gravity, Args.Gravity))%interval;
        simpleProcessing(ID, (!ModdedTimeToMaxHeight ? interval : ModdedTimeToMaxHeight) + deltaT, Color.SkyBlue, BeamType.GoodBeam, i => {return Args.StartPosition;}); //First EC. If there is no TTMH (the proj is created past its apex), run a full interval EC check
        
        //First StateCheck. If the proj spawns close to a player, it should be in the complex state
        StateCheck(ID, Args.StartPosition);

        //Number maxWait_1: 0.016*4;
        //Number maxWait_2: 0.016*5;

        Number p0: 31.25;
        Number p1: 5;
        Number p2: 5;

        Number a0: (LinearInterpolate(p0, p1, ServerLoadPeak()/255));
        Number a1: (LinearInterpolate(p1, p2, ServerLoadPeak()/255));

        Number b0: (LinearInterpolate(a0, a1, ServerLoadPeak()/255));
        
        //Wait(ServerLoadPeak() >= 200 ? 0.032 : 0.016);
        //Wait(LinearInterpolate(0.016, maxWait_1, ServerLoadAverage()/255));
        if (deltaT < deltaTMax) {
            Wait(0.5/b0);
        }
//        else {
            //MinWait();
            //LogToInspector($"proj {ID} fired w/o waits");
//        }

        //The projectile can be destroyed very early, if it collides with smth before the first wait is over. If that happens, dont bother with creating it
        if (projData[ID].ProjState != ProjState.Inactive && projData[ID].ProjState != ProjState.NULL)
        {
            SyncTTE();
            LogToInspector($"Kept Creation! (proj {ID}, tick {(tte / 0.016).Floor()})");
            CastPFX(
                pfx: Args.ProjFX,
                fx => {
                    CreateProjectileEffect(AllPlayers(), fx, AllPlayers(), UpdateEveryFrame(projData[EvaluateOnce(ID)].Position), projData[EvaluateOnce(ID)].ReadOnly.Velocity + projData[EvaluateOnce(ID)].ReadOnly.Gravity * projData[EvaluateOnce(ID)].time, EvaluateOnce(Args.Oversize), ProjectileEffectReeval.PositionDirectionAndSize);
                    }
            );
            //projData_VFX[ID] = LastCreatedEntity();
            projData[ID].ReadOnly.VFX = LastCreatedEntity();
            //projData[ID].ReadOnly.VFX.ModAppend(LastCreatedEntity());

            ProjDestructor.Queue(ID, Args.Lifetime - deltaT);

            //If the server load is on the higher side, limit the constructor rate so THE BUG happens less
            //Wait(ServerLoadPeak() >= 150 ? 0.032 : 0.016);
            //Wait(LinearInterpolate(0.016, maxWait_2, ServerLoadAverage()/255));
            if (deltaT < deltaTMax) {
                Wait(0.5/b0);
            }
    //        else {
                //MinWait();
    //        }
        } else {LogToInspector($"Skipped creation! (proj {ID}, tick {(tte / 0.016).Floor()})");}
    }
    else
    {
        //This else will happen if a proj is queued without any info for args
        if (!CountOf(Args))
        {

        }

        //This will happen if the proj has a deltaT >= lifetime
        else
        {
            projData[ID].ProjState = ProjState.Inactive;
        }

        //LogToInspector("\n\n!--ELSE FIRED--!\n\n");
    }

    //All done with first in queue, get ready for next
    projConstructor.ModRemoveByIndex(0); 

    LoopIfConditionIsTrue();
    //LogToInspector($"NO LOOP ({projConstructor.Length} Con Queues)");
    MinWait();
    LoopIfConditionIsTrue();
}


