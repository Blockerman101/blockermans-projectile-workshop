import "structs.del";

globalvar ProjDestructor[] projDestructor = []; 

rule: '[BMPW] Destructor - Add filler values'
Event.OngoingGlobal
if (TotalTimeElapsed() >= projDestructor.First.time && projDestructor.Length)
{
    Number ID: projDestructor.First.ID;
    DestroyEffect(projData_VFX[ID]);
    projData[ID].ProjState = ProjState.Inactive;
    complexProjs.ModRemoveByValue(ID);
    Boolean[] reqsForDec: [
    timeInInterval.Length > 1,
    currentTick >= timeInInterval[timeInInterval.Map(v => v.ID).IndexOf(ID)].Time
];
    if (IsTrueForAll(reqsForDec, ArrayElement())) {LogToInspector($"Dec'd Index. (Index {timeInInterval.Map(v => v.ID).IndexOf(ID)} with ID {ID}, Index: {intervalIndex} -> {intervalIndex + 1})"); intervalIndex--;}
    TimeInInterval.ClearFromQueue(ID);

    ProjDestructor.ClearFromQueue(ID); //Do this last, ID is tied to ProjDestructor
    MinWait();
    LoopIfConditionIsTrue();
}

Any cond: projData.All(v => v.ProjState == ProjState.Inactive || !CurrentArrayIndex()) && projData.Length > 1; //If all real projectiles are Inactive
rule: '[BMPW] Destructor - Clear Projectile Data'
Event.OngoingGlobal
if (cond && !projConstructor.Length)
{
    Wait(0.25, WaitBehavior.AbortWhenFalse);
    DestroyEffect(projData_VFX);
    projData = [ProjData.Construct()];
    projData_VFX = [0];
    projConstructor = [];
    projDestructor = [];
    timeInInterval = [];
    complexProjs = [];
    lastProjectileID = 0;
    intervalIndex = 0;
    MinWait();
    LoopIfConditionIsTrue();
}