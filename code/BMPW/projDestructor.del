import "structs.del";

globalvar ProjDestructor[] projDestructor = []; 

rule: '[BMPW] Destructor - Destroy Proj'
Event.OngoingGlobal
if (TotalTimeElapsed() >= projDestructor.First.time && projDestructor.Length)
{
    Number ID: projDestructor.First.ID;

    //DestroyEffect(projData_VFX[ID]);
    DestroyEffect(projData[ID].ReadOnly.VFX);
    LogToInspector($"Destroyed fx {projData[ID].ReadOnly.VFX} from proj {ID}");
    projData[ID].ProjState = ProjState.Inactive;
    complexProjs.ModRemoveByValue(ID);

    Boolean[] reqsForDec: [
    //timeInInterval.Length > 1,
    currentTick >= timeInInterval[timeInInterval.Map(v => v.ID).IndexOf(ID)].Time,
    intervalIndex //make sure it isnt 0, because if it was it would go to index -1
];
    if (IsTrueForAll(reqsForDec, ArrayElement())) {
        //LogToInspector($"Dec'd Index. (Index {timeInInterval.Map(v => v.ID).IndexOf(ID)} with ID {ID}, Index: {intervalIndex} -> {intervalIndex + 1})");
        intervalIndex--;
        }

    //This doesnt need to maintain indices like projData, so when a projectile is made Inactive, its simply removed from this array
    TimeInInterval.ClearFromQueue(ID);

    LogToInspector($"Destroyed Proj {ID} (Tick {(time/0.016).Floor()})");

    //Do this last, ID is tied to ProjDestructor
    ProjDestructor.ClearFromQueue(ID); 

    MinWait();
    //The closest power of 2 to the size of projData, rounded down (so if length is 25, this is 16, so you can check)
    _waitlessIterator = [4, 8, 16, 32, 64, 128, 256].Filter((v, idx) => projData.Length - 1 > v).Last;
    Number floorPowerOfTwo: _waitlessIterator;

    //Half the size of the database, if possible
    if (projData.All(v => v.ProjState == ProjState.Inactive || CurrentArrayIndex() <= floorPowerOfTwo) && floorPowerOfTwo)
    {
        //LogToInspector($"size: {projData.Length}, FPOT: {floorPowerOfTwo}");

        //want the indices from 0 through floorPowerOfTwo
        _waitlessIterator = projData.Map(v => CurrentArrayIndex() <= floorPowerOfTwo ? CurrentArrayIndex() : -1).Filter(i => i != -1);
        Number[] indexes: _waitlessIterator;
        projData = indexes.Map(v => projData[v]);
        //projData = projData[indexes];
        //projData = projData.Filter((v, idx) => idx < floorPowerOfTwo);
        //LogToInspector($"Made size smaller! (shrank to {floorPowerOfTwo}, from {indexes.First} through {indexes.Last})");
    }
    LoopIfConditionIsTrue();
}

Any cond: projData.All(v => v.ProjState == ProjState.Inactive || !CurrentArrayIndex()) && projData.Length > 1; //If all real projectiles are Inactive
rule: '[BMPW] Destructor - Clear Projectile Data'
Event.OngoingGlobal
if (cond && !projConstructor.Length)
{
    Wait(0.25, WaitBehavior.AbortWhenFalse);
    DestroyEffect(projData.Map(v => v.ReadOnly.VFX));
    WipeData();

    MinWait();
    LoopIfConditionIsTrue();
}

private void WipeData() {
    projData = [ProjData.Construct()];
    //projData_VFX = [0];

    projConstructor = [];
    projDestructor = [];

    timeInInterval = [];
    intervalIndex = 0;

    complexProjs = [];
    
    lastProjectileID = 0;
}