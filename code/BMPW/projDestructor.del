import "structs.del";

globalvar ProjDestructor[] projDestructor = []; 

rule: '[BMPW] Destructor - Destroy Proj'
Event.OngoingGlobal
if (tte >= projDestructor.First.time && projDestructor.Length)
{
    Number ID: projDestructor.First.ID;

    //DestroyEffect(projData_VFX[ID]);
    DestroyEffect(projData[ID].ReadOnly.VFX);
    projData[ID].ProjState = ProjState.Inactive;
    complexProjs.ModRemoveByValue(ID);

    Boolean[] reqsForDec: [
    timeInInterval.Length > 1,
    currentTick >= timeInInterval[timeInInterval.Map(v => v.ID).IndexOf(ID)].Time,
    intervalIndex //make sure it isnt 0, because if it was it would go to index -1
];
    if (IsTrueForAll(reqsForDec, ArrayElement())) {
        //LogToInspector($"Dec'd Index. (Index {timeInInterval.Map(v => v.ID).IndexOf(ID)} with ID {ID}, Index: {intervalIndex} -> {intervalIndex + 1})");
        intervalIndex--;}
    TimeInInterval.ClearFromQueue(ID);

    //LogToInspector($"Destroyed Proj {ID} (Tick {(time/0.016).Floor()})");

    //Do this last, ID is tied to ProjDestructor
    ProjDestructor.ClearFromQueue(ID); 

    MinWait();
    LoopIfConditionIsTrue();
}

disabled rule: '[BMPW] Destructor - Remove Hanging Indices'
if (projData.Last.ProjState == ProjState.Inactive)
if (projData.Length > 1)
{
    Wait(0.016, WaitBehavior.AbortWhenFalse);

    //using as a temp var
    _waitlessIterator = (projData.Map(v => v.HitPlayer).Length - 1);
    Number last: _waitlessIterator;

    //projData_VFX.ModRemoveByIndex(last);

    //If the last index is inactive, remove it. Minimizes array size
    DestroyEffect(projData[last].ReadOnly.VFX);
    projData.ModRemoveByIndex(last);
    //LogToInspector($"\n\nRemoved hanging index\n\n");

    //Reset system if there are no active projectiles
    if (projData.Length == 1) {
        WipeData();
    }

    LogToInspector($"asdfasdf");
    
    LoopIfConditionIsTrue();
}

Any cond: projData.All(v => v.ProjState == ProjState.Inactive || !CurrentArrayIndex()) && projData.Length > 1; //If all real projectiles are Inactive
rule: '[BMPW] Destructor - Clear Projectile Data'
Event.OngoingGlobal
if (cond && !projConstructor.Length)
{
    Wait(0.25, WaitBehavior.AbortWhenFalse);
    DestroyEffect(projData.Map(v => v.ReadOnly.VFX));
    WipeData();

    MinWait();
    LoopIfConditionIsTrue();
}

private void WipeData() {
    projData = [ProjData.Construct()];
    //projData_VFX = [0];

    projConstructor = [];
    projDestructor = [];

    timeInInterval = [];
    intervalIndex = 0;

    complexProjs = [];
    
    lastProjectileID = 0;
}