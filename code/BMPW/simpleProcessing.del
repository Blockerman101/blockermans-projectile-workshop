import "projConstructor.del";
import "complexProcessing.del";

globalvar private RaycastPositions tempPositions;
globalvar Number intervalIndex;

rule: '[BMPW] Reset intervalIndex on lap end'
if (timeInInterval.Length)
//if (currentTick == 0 || currentTick == 1)
if (!currentTick)
{
    intervalIndex = 0;
    LogToInspector($"Lap ended. (Index returned to 0) (TTE: {time})");
}

Boolean diff(in Number ID): (timeInInterval[ID].Time == currentTick);
rule: '[BMPW] Check EC'
//This might fix a (potential?) bug
if (intervalIndex < timeInInterval.Length)
if (diff(intervalIndex))
{
    //Adding a bit to interval so the checks slightly overlap, prevents edgecase bugs
    simpleProcessing(timeInInterval[intervalIndex].ID, (interval + 0.032), Color.White, BeamType.BadBeam, ID => {return projData[ID].Position;}); //Check this projectile
    intervalIndex++; //Traverse to the next projectile
    WaitUntil((diff(intervalIndex) || !intervalIndex) && intervalIndex < timeInInterval.Length , interval - (time%interval)); //Wait until the next proj is ready to be checked, and if either if the loop ends, or until there is a value at timeInInterval[intervalIndex].Time
    //Heres the reason why '&& intervalIndex < timeInInterval.Lengh' is needed: First off, this code makes sure that your not reading an out-of-scope index.
    //Take the case where there is 1 projectile, with a ProjTick of 0. When the Current Tick is 0, it will check Proj 1, then traverse to Proj 2.
    //Because there is no Proj 2, diff(1) corresponds to timeInInterval[1].Time == 0 -> null == 0 -> true. Therefore, the WaitUntil never happens, and it loops to the next check.
    //This happens an infinite amount of times (with 0 waits inbetween), crashing the server.
    LoopIfConditionIsTrue();
}

rule: '[BMPW] Update State'
if (timeInInterval.Length)
{
    SpreadOverTicks(timeInInterval, 15, tte, i => {
        //i is the index of the array entered
        StateCheck(i.ID, projData[i.ID].Position);
        //LogToInspector($"Checked state of proj {i} (TTE: {time})");
    });
}

Boolean approxEqual(in Number one, in Number two, in Number leniency): ((one - two).Abs() <= leniency);
Number rawInterval: 0.5; //How often to check for collision
Number interval: ((rawInterval / 0.016).Ceil() * 0.016); //Rounded up to the nearest multiple of 0.016 (Rounded up to the nearest tick)

//Cant use tte because of the bug with chased vars in conditions
Number time: TotalTimeElapsed();
Number currentTick: ((time%interval) / 0.016).Floor();
//Number rayCastCount: 1;

private void simpleProcessing(in Number ID, in Number interval, in Color color, BeamType beamType, const Number => Vector StartPosition) {
    LogToInspector($"coll checked! (ID: {ID}, CurrentTII: {currentTick}, interval: {interval}, TTE: {time})");
    tempPositions.StartPosition = StartPosition(ID);
    tempPositions.EndPosition = projData[ID].PositionAtTime(interval);
    //This will need to include targets in order for their objects to be tracked
    tempPositions.RaycastPosition = RayCastHitPosition(tempPositions.StartPosition, tempPositions.EndPosition, projData[ID].ReadOnly.Targets, null, true);
    Vector position: tempPositions.StartPosition;
    Vector endPosition: tempPositions.EndPosition;
    Vector raycast: tempPositions.RaycastPosition;


    //Structuring the state check like this allows us to reuse the projs position instead of recalculating it
    //StateCheck(ID, position);

        //if (IsTrueForAny([position, endPosition, raycast], ArrayElement() == Vector.Zero)) {LogToInspector("!--POSITIONS REGISTERED ZERO--!");}

        CreateBeamEffect(HostPlayer(), beamType, position, raycast, Color.Red, EffectRev.None);
        projData[ID].ReadOnly.VFX.ModAppend(LastCreatedEntity());
        CreateEffect(HostPlayer(), Effect.Sphere, color, raycast, 0.25, EffectRev.None);
        projData[ID].ReadOnly.VFX.ModAppend(LastCreatedEntity());
        

//        if ([position, endPosition, raycast].IsTrueForAny(v => v == Vector.Zero)) {LogToInspector($"POSITIONS REGISTERED ZERO");}
    if (raycast != endPosition) 
    {
        //By making the queue time {offset} shorter, you avoid false positives with PC (take the case of a projectile hitting reins shield)
        //^ not needed if you just include objs in PD
        Number offset: 0.016*0;
        Number timeToDestroy: interval * Min(1, Max(0, LinearInterpolate(0, 1, (position.DistanceTo(raycast)/position.DistanceTo(endPosition))))) - offset;
        ProjDestructor.Queue(ID, timeToDestroy); //Cant add an offset for visuals because it would mess up ricochets
        LogToInspector($"Collided! (Proj {ID} queued with {timeToDestroy} seconds\n(Current Tick {(TotalTimeElapsed() / 0.016).Floor()} with {((timeToDestroy) / 0.016).Floor()} ticks to destruction\nExpected to be destroyed at tick {((time + timeToDestroy) / 0.016).Floor()}))");
        //break;
    } //stop raycasting if the latest one hit
}
Number speed(in Number ID): projData[ID].ReadOnly.Velocity.Magnitude;
Number inter: 0.24;

//projRad + baseRad + scalar * speed * intervalOfSC
Number rad(in Number ID): projData[ID].ReadOnly.Radius + 4 + 0.5 * speed(ID) * inter;

//The faster a proj is going, the more you can assume ahead of it to be the checked position
Vector pos(in Number ID): projData[ID].PositionAtTime(inter * Min(1, speed(ID) / 85));
private void StateCheck(in Number ID, in Vector position)
{
    //Criteria for complex state
    if (projData[ID].ReadOnly.Targets.Any(v => v.DistanceTo(pos(ID)) <= rad(ID)))
    {
        if (complexProjs.All(v => v != ID))
        {
            complexProjs.ModAppend(ID);
            //This should be the same as ticks in PD
            checkPCollision(ID, 5);
        }
    }
    else
    {
        complexProjs.ModRemoveByValue(ID);
    }
}